namespace tc {

  namespace precomp {

    namespace instance {
      % Tells if the current name is a bound variables
      pred is-name o:term.
      % Tells if the current name stands for a uvar
      pred is-uvar o:term.

      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- !.
      may-contract-to L N (app [V|S]) :- var V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [V|S]) :- is-uvar V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ (app [N|_]) :- is-uvar N, !, fail.
      occurs-rigidly _ (app [N|_]) :- var N, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      maybe-eta-aux (app[V|S]) L :- is-uvar V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app[V|S]) L :- var V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred free-var o:list term.
      free-var L :-
        std.findall (is-name _) T,
        std.map T (x\y\ x = is-name y) L.

      pred split-pf i:list term, i:list term, o:list term, o:list term.
      split-pf [] _ [] [] :- !.
      split-pf [X|Xs] Old [X|Ys] L :- is-name X, not (std.mem! Old X), !, split-pf Xs [X|Old] Ys L.
      split-pf Xs _ [] Xs.

      kind positivity type.
      type is_pos positivity.
      type is_neg positivity.
      type is_neg_fix positivity.

      :index (1 _)
      pred neg i:positivity, o:positivity.
      neg is_pos is_neg :- !.
      neg is_neg is_pos :- !.
      neg is_neg_fix is_neg_fix :- !.

      % TODO: this is incomplete: it lacks of some term constructors
      pred count-maximal-arity-aux i:term, i:term, o:nat.
      count-maximal-arity-aux _ N z :- name N, !.
      count-maximal-arity-aux T (app [T|L]) R :- !,
        length-nat L Len,
        std.fold L Len (x\y\w\ sigma M\ count-maximal-arity-aux T x M, max-nat y M w) R.
      count-maximal-arity-aux T (app [_|L]) R :- !,
        std.fold L z (x\y\w\ sigma M\ count-maximal-arity-aux T x M, max-nat y M w) R.
      count-maximal-arity-aux T (fun _ Ty B) R2 :- !,
        count-maximal-arity-aux T Ty R,
        (pi x\ count-maximal-arity-aux T (B x) R1),
        max-nat R R1 R2.
      count-maximal-arity-aux T (prod _ Ty B) R2 :- !,
        count-maximal-arity-aux T Ty R,
        (pi x\ count-maximal-arity-aux T (B x) R1),
        max-nat R R1 R2.
      count-maximal-arity-aux _ (global _) z :- !.
      count-maximal-arity-aux _ (uvar _) z :- !.
      count-maximal-arity-aux _ (sort _) z :- !.
      count-maximal-arity-aux _ (pglobal _ _) z :- !.
      count-maximal-arity-aux A B _ :- coq.error "Count maximal arity failure" A B.

      pred count-maximal-arity i:term, i:term, i:term, o:nat.
      count-maximal-arity _ Ty _ N :- get-TC-of-inst-type Ty _, !, count-prod Ty N.
      count-maximal-arity B _ T N :- !, count-maximal-arity-aux B T N. 

      pred precompile-aux i:positivity, i:term, i:nat, o:term, o:nat.
      precompile-aux _ X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux _ (global _ as C) A C A :- !.
      precompile-aux _ (pglobal _ _ as C) A C A :- !.
      precompile-aux _ (sort _ as C) A C A :- !.

      % Detect maybe-eta term
      % TODO: should I precompile also the type of the fun and put it in the output term
      precompile-aux _ (fun Name Ty B as T) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
        maybe-eta T, !,
        free-var Scope,
        precompile-aux is_neg_fix Ty N _ N',
        (pi x\ is-name x => precompile-aux is_neg_fix (B x) N' (B' x) M).

      precompile-aux _ (app [X|XS]) N (tc.maybe-llam-tm (app [app[X | PF] | NPF1]) Scope) (s M) :-
        if (is-uvar X) (Sc = []) (var X _ Sc), split-pf XS Sc PF NPF, 
        not (NPF = []), !, % else XS is a list of distinct names, i.e. `app [X|XS]` is in PF
        free-var Scope,
        std.fold-map NPF N (precompile-aux is_neg_fix) NPF1 M. 

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux IsP (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        std.assert! (pi x\ count-maximal-arity x Ty (B x) MaxAr) "[TC] count-maximal-arity should not fail",
        if (IsP = is_pos) (C = x\ is-uvar x) (C = x\ is-name x),
        std.assert! (pi x\ C x => precompile-aux IsP (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux {neg IsP} Ty M Ty' P.

      % Working with fun
      precompile-aux _ (fun N T F) A (fun N T1 F1) A2 :- !,
        precompile-aux _ T A T1 A1, pi x\ is-name x => precompile-aux is_neg_fix (F x) A1 (F1 x) A2.
      
      precompile-aux _ (app L) A (app L1) A1 :- !, std.fold-map L A (precompile-aux is_neg_fix) L1 A1.
      precompile-aux _ X A X A :- var X, !.

      % TODO: what about the following constructors?
      % precompile-aux IsP (let N T B F) A (let N T1 B1 F1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP B A1 B1 A2, pi x\ is-name x => precompile-aux IsP (F x) A2 (F1 x) A3.
      % precompile-aux IsP (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
      %   precompile-aux IsP Ty A Ty1 A1, pi x\ is-name x => precompile-aux IsP (F x) A1 (F1 x) A2.
      % precompile-aux IsP (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP Rty A1 Rty1 A2, std.fold-map B A2 (precompile-aux IsP) B1 A3.
      % precompile-aux _ (primitive _ as C) A C A :- !.
      % precompile-aux IsP (uvar M L as X) A W A1 :- var X, !, std.fold-map L A (precompile-aux IsP) L1 A1, coq.mk-app-uvar M L1 W.
      % % when used in CHR rules
      % precompile-aux IsP (uvar X L) A (uvar X L1) A1 :- std.fold-map L A (precompile-aux IsP) L1 A1.

      pred get-univ-instances i:term, o:list univ-instance.
      get-univ-instances T L :-
        (pi x L\ fold-map (pglobal _ x) L _ [x | L] :- !) => fold-map T [] _ L, !.

      pred get-univ i:term, o:list univ.
      get-univ T L :-
        coq.univ.variable.set.elements {coq.univ.variable.of-term T} Vars,
        std.map Vars (x\r\ coq.univ.variable r x) L.

    }

    /*
      [tc.precomp.instance T T' N] 
      Returns T' N from T, where: 
        T' is obtained by the replacement of
          - all maybe-eta term `t1` with (tc.maybe-eta-tm `t1` `s`) where `s` = FV(`t1`)
              ==> This helps knowing if a subterm should be replaced with a `eta-link`
          - all `prod _ Ty (x\ Bo x)` with (tc.maybe-beta-tm (prod _ Ty (x\ Bo x)) N), 
            where N is represent the "maximal" application of `x` in `Bo`
              for example:
                let Ty = {{Type -> Type -> Type -> Type -> Type}},
                and Bo = x\ c1 (x nat bool) (x nat) (x nat nat bool)
              the term `prod _ Ty Bo` is replaced with
                (tc.maybe-beta-tm (prod _ T Bo) 3)
              since x is applied at most 3 times in Bo
                ==> This helps charging the right number of `eta-link` for map-deduplication rule
        N is the number of problematic terms in T
    */
    pred instance i:term, o:term, o:nat, o:list univ, o:list univ-instance.
    instance T T' N UnivConstL UnivInstL :-
      tc.precomp.instance.get-univ T UnivConstL,
      tc.precomp.instance.get-univ-instances T UnivInstL,
      std.assert!(instance.precompile-aux instance.is_pos T z T' N) "[TC] cannot precompile instance".

    namespace goal {
      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- !.
      % TODO: here we should do var V _ Scope and use scope: N can be in Scope but not in S
      may-contract-to L N (app [V|S]) :- var V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ (app [N|_]) :- var N, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      % TODO: here we should do var V _ Scope and use Scope: an elt in L can appear in Scope
      maybe-eta-aux (app[V|S]) L :- var V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred split-pf i:list term, i:list term, o:list term, o:list term.
      split-pf [] _ [] [] :- !.
      split-pf [X|Xs] Old [X|Ys] L :- name X, not (std.mem! Old X), !, split-pf Xs [X|Old] Ys L.
      split-pf Xs _ [] Xs.

      pred precompile-aux i:term, i:list term, o:term, o:list term.
      precompile-aux X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux (global _ as C) A C A :- !.
      precompile-aux (pglobal _ _ as C) A C A :- !.
      precompile-aux (sort _ as C) A C A :- !.

      % Detect maybe-eta term
      precompile-aux (fun Name Ty B as T) N (tc.maybe-eta-tm (fun Name Ty' B') Scope) M :-
        maybe-eta T, !,
        names Scope,
        (pi x\ precompile-aux (B x) N (B' x) M'),
        precompile-aux Ty M' Ty' M.

      % Detect maybe-beta term
      precompile-aux (app [X|XS]) N (tc.maybe-llam-tm (app [app[X | PF] | NPF1]) Scope1) [X|M] :-
        var X _ Scope, split-pf XS Scope PF NPF, 
        not (NPF = []), !, % else XS is a list of distinct names, i.e. `app [X|XS]` is in PF
        names Scope1,
        std.fold-map NPF N precompile-aux NPF1 M. 

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        count-prod Ty MaxAr,
        std.assert! (pi x\ precompile-aux (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux Ty M Ty' P.

      % Working with fun
      precompile-aux (fun N T F) A (fun N T F1) A2 :- !, A = A1,
        /*precompile-aux IsP T A T1 A1,*/ pi x\ precompile-aux (F x) A1 (F1 x) A2.
      
      precompile-aux (app L) A (app L1) A1 :- !, std.fold-map L A precompile-aux L1 A1.
      precompile-aux (let N T B F) A (let N T1 B1 F1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux B A1 B1 A2, pi x\ precompile-aux (F x) A2 (F1 x) A3.
      precompile-aux (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
        precompile-aux Ty A Ty1 A1, pi x\ precompile-aux (F x) A1 (F1 x) A2.
      precompile-aux (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux Rty A1 Rty1 A2, std.fold-map B A2 precompile-aux B1 A3.
      precompile-aux (primitive _ as C) A C A :- !.
      precompile-aux X A X [X|A] :- var X, !.
    }

    pred goal i:term, o:term, o:list term.
    goal T T' Vars' :- std.assert!(goal.precompile-aux T [] T' Vars) "[TC] cannot precompile goal", undup-same Vars Vars'. 
  }
}