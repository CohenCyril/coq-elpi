/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

pred time-solve i:prop.
time-solve P :-
  std.time P Time,
  if-true (is-option-active oTC-time) 
    (coq.say "[TC] Total resolution time is:" Time).

msolve L N :- time-solve (coq.ltac.all (coq.ltac.open solve-aux) L N).
msolve L _ :- coq.ltac.fail _ "[TC] fail to solve" L.

pred build-query-from-goal i:term, i:term, o:prop, o:list prop.
build-query-from-goal Goal Proof Q PostProcess :-
  tc.compile.goal Goal Goal' PostProcess, !,
  coq.safe-dest-app Goal' (global TC) TL',
  std.append TL' [Proof] TL, !,
  coq.elpi.predicate {gref->pred-name TC} TL Q.

% [tc-recursive-search Goal Solution] takes the type of the goal and solves it
pred tc-recursive-search i:term, o:term.
tc-recursive-search Goal Proof :- 
  std.time (build-query-from-goal Goal Proof Q PostProcess) TimeBQ,
  if-true print-compiled-goal (coq.say "[TC] the compiled goal is" Q),
  std.time (
    do PostProcess, Q,
    tc.link.solve-eta, % Trigger eta links
    tc.link.solve-llam % Trigger llam links
  ) TimeSearch,
  if-true (is-option-active oTC-time-build-query) (coq.say "[TC] Time build query is" TimeBQ),
  if-true (is-option-active oTC-time-instance-search) (coq.say "[TC] Instance search time is:" TimeSearch).

pred refine-proof i:term, i:goal, o:list sealed-goal.
refine-proof Proof G GL :-
  if (is-option-active oTC-eta-reduce-proof) 
    (coq.reduction.eta-contract Proof Proof')
    (Proof' = Proof),
  if-true (print-solution) (coq.say "[TC] The proof is <<<" Proof' ">>>"),
  if-true (print-solution-pp) (coq.say "[TC] The proof is <<<" {coq.term->string Proof'} ">>>"),
    
  /*********** CHECK IF THE PROOF TYPECHECKS ***********/
  std.time (@no-tc! => refine.typecheck Proof' G GL) Refine-Time,
  
  if-true (print-solution) (coq.say "[TC] The proof typechecks"),
  if-true (is-option-active oTC-time-refine) 
    (coq.say "[TC] Refine time is:" Refine-Time).

pred solve-w-modes i:term, i:goal, o:list sealed-goal.
solve-w-modes Ty G GL :-
  std.time (modes-check Ty) TimeMC, !,
  if-true (is-option-active oTC-time-mode-check) (coq.say "[TC] Time mode check is" TimeMC),
  tc-recursive-search Ty Proof,
  refine-proof Proof G GL.
solve-w-modes _ G [seal G].

pred solve-aux i:goal, o:list sealed-goal.
:name "solve-aux-intros"
solve-aux (goal Ctx _A (prod N X T) B Args) GL :- !,
  @pi-decl N X x\
    solve-aux (goal [decl x N X | Ctx] _A' (T x) (B' x) Args) GL,
    B'' = fun N X B',
  if (true ; is-option-active oTC-eta-reduce-proof) 
    (coq.reduction.eta-contract B'' B)
    (B'' = B).

:name "solve-aux-conclusion"
solve-aux (goal Ctx _ TyRaw uvar _ as G) GL :-
  tc.compile.context Ctx CtxClause,
  do-once (normalize-ty TyRaw Ty),
  if-true (print-goal) (coq.say "The goal is <<<" Ty ">>>"),
  if-true (print-goal-pp) (coq.say "The goal is <<<" {coq.term->string Ty} ">>>"),
  CtxClause => solve-w-modes Ty G GL.


pred print-solution.      % Print the solution in HOAS
pred print-solution-pp.   % Print the solution in coq pp
pred print-goal.          % Print the goal in HOAS
pred print-goal-pp.       % Print the goal with coq pp
pred print-compiled-goal.

main _.