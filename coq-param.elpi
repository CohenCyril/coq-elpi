/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% improve coq-env-indt->decl and subst-prod by calling whd %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:before "coq-env-indt->decl:fail"
coq-env-indt->decl T Lno Iname Kns Ktys Idecl :-
  unwind {whd T []} R,
  assert (R = prod _ _ _) "coq-env-indt->decl: Lno > #products(arity)",
  coq-env-indt->decl R Lno Iname Kns Ktys Idecl.

:before "subst-prod:fail"
subst-prod ([X|XS] as Args) T P :-
  unwind {whd T []} R,
  assert (R = prod _ _ _) "subst-prod: not a prod even after whd",
  subst-prod Args R P.

%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional primitives %
%%%%%%%%%%%%%%%%%%%%%%%%%

pred abstract i:term, i:(list term), i:term, o:term.
% @log(abstract T Args Prod Lam).
abstract T [] _ T' :- !, copy T T'.
abstract T [X|XS] (prod N Ty Tys) (lam N Ty R) :- !,
  pi x\ copy X x => abstract T XS (Tys x) (R x).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parametricty translation %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred param-args i:int, i:(list term), o:(list (list term)), o:(list term).
param-args _Nary [] [] [] :- !.
%@log(param-args _ _ _).
param-args Nary [X|Xs] [X1|Xs1] Res :- !,
  param Nary X X1 XR, !, param-args Nary Xs Xs1 XsR, !.
  flatten [[X],X1,[XR|XsR]] Res.

pred map-param i:int, i:(list term), o:(list (list term)), o:(list term).
map-param _Nary [] [] [] :- !.
map-param Nary [X|Xs] [X1|Xs1] [XR|XsR]:- !,
  param Nary X X1 XR, !, map-param Nary Xs Xs1 XsR, !.

pred nseq i:int, i:A, o:(list A).
nseq 0 X [] :- !.
nseq N X [X|Xs] :- N > 0, !, N' is N - 1, nseq N' X Xs.

pred fold-op2 i:(A -> B -> (C -> C) -> C),
  i:(list A), i:(list B), o:((list C -> C) -> C).
%@log(fold-op2 _ _ _ _).
fold-op2 Op [] [] (subst\ subst []) :- !.
fold-op2 Op [A|As] [B|Bs] Ops :- !,
  fold-op2 Op As Bs Ops', !,
  Ops = subst\ Op A B (x\ Ops' args\ subst [x|args]).
fold-op2 _Op [] [_|_] _ :- fatal-error "fold-op2: list size mismatch".
fold-op2 _Op [_|_] [] _ :- fatal-error "fold-op2: list size mismatch".

pred fold-op3 i:(A -> B -> C -> (D -> D) -> D),
  i:(list A), i:(list B), i:(list C), o:((list D -> D) -> D).
%@log(fold-op3 _ _ _ _).
fold-op3 Op [] [] [] (subst\ subst []) :- !.
fold-op3 Op [A|As] [B|Bs] [C|Cs] Ops :- !,
  fold-op3 Op As Bs Cs Ops', !,
  Ops = subst\ Op A B C (x\ Ops' args\ subst [x|args]).
fold-op3 _Op [] [] [_|_] _ :- fatal-error "fold-op3: list size mismatch".
fold-op3 _Op [] [_|_] [] _ :- fatal-error "fold-op3: list size mismatch".
fold-op3 _Op [_|_] [] [] _ :- fatal-error "fold-op3: list size mismatch".

pred hoas-flatten i:int, i:(list term -> list term), o:(list (term -> term)).
hoas-flatten N F L :-
  (pi x\ map (F {nseq N x}) (a\ res\ pi y\ copy x y => res y = {copy a}) L). 

% pred mk-arrows i:int, i:term, o:((list term -> term).
% mk-arrows 0 Concl (xs\ Concl) :- !.
% mk-arrows N Concl (xs\ ) :- N > 0, !,
%   N' is N - 1,
%   mk-arrows N' Concl Arrows


pred param i:int, i:term, o:(list term), o:term.
%@log(param Nary P _ _).
param Nary (sort _ as P) Ps (LamR Prods) :- !,
  nseq Nary "s" Names, nseq Nary P Ps, !,
  fold-op2 lam ["s"|Names] [P|Ps] LamR,
  pi xs\ fold-op2 prod ["s"|Names] xs (Prods xs)

param Nary (lam N T B) Lam1 LamR :- !,
  nseq Nary N Names, param Nary T T1 TR, !,
  (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  map3 Names T1 B1s (n\ t\ b\ res\ res = lam n t b) Lam1, !,
  fold-op2 lam Names T1 Lam1s, 
  LamR = lam N T x\ Lam1s x1\ lam N {mk-app TR [x|x1]} xR\ BR x x1 xR.

param Nary (prod N T P as Prod) Prod1 ProdR :- !,
  nseq Nary N Names, param Nary T T1 TR, !,
  (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  map3 Names T1 B1s (n\ t\ b\ res\ res = prod n t b) Prod1, !,
  fold-op2 prod Names T1 Prod1s,
  fold-op2 lam {nseq Nary "f"} Prod1 Lam1s,
  (pi f fs x x1\ map2 [f|fs] [x|x1] (f\v\res\ mk-app f v res)
    (ProdArgs f fs x x1)),
  ProdR = lam "f" Prod f\ Lam1s fs\
          prod N T x\ Prod1s x1\ prod N {mk-app TR [x|x1]} xR\
	  {mk-app (PR x x1 xR) (ProdArgs f fs x x1)}.

param Nary (app [A|Bs]) A1Bs1 ARBsR :- !,
   param Nary A A1 AR, !, param-args Nary Bs Bs1 BsR, !,
   map2 A1 Bs1 mk-app A1Bs1, !, mk-app AR BsR ARBsR.

param Nary (let N T V B) Let1 LetR :- !,
  nseq Nary N Names, param Nary T T1 TR, !, param Nary V V1 VR, !,
  (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  map4 Names T1 V1 B1s (n\ t\ v\ b\ res\ res = let n t v b) Let1, !,
  fold-op3 let Names T1 V1 Let1s,
  LetR = let N T V x\ Let1s x1\ let N TR VR xR\ BR x x1 xR.
  
param Nary (match T P Bs) M1 MR :- !,
  param Nary T T1 TR, !, param-match Nary P P1 PRM, !,
  param Nary T T1 TR => map-param Nary Bs Bs1 BsR, !,
  hoas-flatten Nary B1 B1s, !,
  map3 T1 P1 Bs1 (x\y\z\res\ res = match x y z) M1,
  map2 [P|P1] [Bs|Bs1] (p\bs\res\ res = x\ match x p bs) PRMArgs,
  MR = match TR (PRM PRMArgs) BsR.

% param (fix N Rno T F as Fix) Fix1 FixR :- !,
%   RnoR is 3 * Rno + 2, RnoR1 is RnoR + 1,
%   param T T1 TR, !,
%   (pi x x1 xR\ param x x1 xR => param (F x) (F1 x1) (FR x x1 xR)), !,
%   Fix1 = fix N Rno T1 F1, !,
%   (TRsubst = f\ f1\ {subst-lam [f, f1] TR}), !,
%   coq-typecheck (lam "f" T f\ lam "g" T1 f1\
%                  lam "xR" (TRsubst f f1) xR\ FR f f1 xR) Ty, !,
%   % TODO: add typing constraints for U and U1 before unification
%   unify-eq Ty (prod Nf Tf f\ prod Nf1 Tf1 f1\ prod _ _ xR\
%                 TRsubst (U f) (U1 f1)), !,
%   coq-typecheck (lam "x" Tf U) Tu, !,
%   coq-typecheck (lam "x" Tf1 U1) Tu1, !,
%   (pi f f1 xR\ FixBody f f1 xR =
%      let "U" Tu (lam Nf Tf U) u\ let "U1" Tu1 (lam Nf1 Tf1 U1) u1\
%      let "FR" (TRsubst {mk-app u [f]} {mk-app u1 [f1]}) (FR f f1 xR) fr\
%       {mk-trivial-match RnoR (TRsubst f f1) [] fr}),
%   (pi f f1 xR\ mk-eta (RnoR + 1) (TRsubst f f1) (FixBody f f1 xR)
%               (EtaFixBody f f1 xR)), !,
%   FixR = (let N T Fix f\ let N T1 Fix1 f1\
%           fix N RnoR (TRsubst f f1) xR\ EtaFixBody f f1 xR).

:name "param:end"
param Nary X _ _ :- !, $coq-say "No" Nary "param for " X, fail.

% pred mk-trivial-match i:int, i:term, i:list term, i:term, o:term.
% %@log(mk-trivial-match _ _ _ _ _).
% mk-trivial-match Rno Prod Args F (lam N T B) :- Rno > 0, !,
%   unify-eq Prod (prod N T P), Rno' is Rno - 1,
%   (pi x \ mk-trivial-match Rno' (P x) [x|Args] F (B x)).
% mk-trivial-match 0 Prod Args F Transport :- !,
%   unify-eq Prod (prod N T P), !,
%   (pi x\ rev [x|Args] (RArgs x)), !,
%   safe-dest-app T (indt Name as Ind) IndArgs, !,
%   coq-env-indt Name _ Lno _Luno IndArity KNames KTypes, !,
%   split-at Lno IndArgs LIndArgs RIndArgs, !,
%   subst-prod LIndArgs IndArity RIndArity, !,
%   abstract (lam N T P) RIndArgs RIndArity MatchType, !,
%   (AbsF = x\ {abstract {mk-app F (RArgs x)} RIndArgs RIndArity}), !,
%   map KNames (k\ subst-lam LIndArgs k) RKs, !,
%   map KTypes (subst-prod LIndArgs) RKTypes, !,
%   map2 RKs RKTypes (mk-branch-lams Lno T AbsF) Branches, !,
%   Transport = (lam N T x \ match x MatchType Branches).

% pred mk-branch-lams i:int, i:term, i:(term -> term), i:term, i:term, o:term.
% % @log(mk-branch-lams _ _ _ _ _).
% mk-branch-lams Lno T F K (prod N Ty P) (lam N Ty B1) :- !,
%   (pi x\ mk-branch-lams Lno T F {subst-lam [x] K} (P x) (B1 x)).
% mk-branch-lams Lno T F K P Let :- !,
%   safe-dest-app P _ ParamIndexes, !,
%   split-at Lno ParamIndexes _Param Indexes, !,
%   (Let = let "K" P K x\ {subst-lam Indexes (F x)}).

% % helpers for match return type

pred param-match i:int, i:term, o:(list term), o:((list (term -> term)) -> term).
param-match Nary (lam N T B) P1 PRM :- pi x\ not (B x = lam _ _ _), !,
  nseq Nary N Names, param Nary T T1 TR, !,
  (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  map3 Names T1 B1s (n\ t\ b\ res\ res = lam n t b) P1, !,
  fold-op2 lam Names T1 Lam1s, 
  (pi zs x x1\ map2 zs [x|x1] (z\x\res\ res = z x) (BRArgs zs x x1)),
  (pi zs\ PRM zs = lam N T x\ Lams1s x1\
                   lam N {mk-app TR [x|x1]} xR\
                   {mk-app (BR x x1 xR) (BRArgs zs x x1)}).

param-match Nary (lam N T B) P1 PRM :-
  nseq Nary N Names, param Nary T T1 TR, !,
  (pi x x1 xR\ param Nary x x1 xR => param-match Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  map3 Names T1 B1s (n\ t\ b\ res\ res = lam n t b) P1, !,
  fold-op2 lam Names T1 Lam1s, 
  (pi zs x x1\ map2 zs [x|x1] (z\x\res\ res = z x) (BRArgs zs x x1)),
  (pi zs\ PRM zs = lam N T x\ Lams1s x1\
                   lam N {mk-app TR [x|x1]} xR\ BR x x1 xR zs).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% translation of inductive types %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred param-indt i:int, i:@gref, i:bool, i:int, i:int, i:term, i:list term, i:list term,
     i:string, o:bool, o:int, o:int, o:term, o:list term, o:list term.
%@log(param-indt _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
param-indt Nary GR IsInd Lno Luno Ty Knames Ktypes
 	   NameR IsInd LnoR LunoR TyR KnamesR KtypesR :- !,
  LnoR is 3 * Lno,
  nseq Nary (indt GR) Ind1,
  param Nary (indt GR) Ind1 (indt NameR) => (
    spy(param Nary Ty _ TyR),
    map Knames (rename-indc NameR) KnamesR,
    map2 Knames Ktypes (param-indc Nary) KtypesR).

pred rename-indc i:string, i:term, o:term.
% @log(rename-indc N I _).
rename-indc NameR (indc GR) (indc NameR') :- !,
  spy(coq-name->string {coq-gr->name GR} Name),
  NameR' is NameR ^ "_" ^ Name.

pred param-indc i:int, i:term, i:term, o:term.
% @log(param-indc N K T _).
param-indc Nary K T TRK :- !,
  param Nary T _ TR,
  nseq Nary K Ks,
  mk-app TR [K|Ks] TRK.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Class storage functions: %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred nat->int i:term, o:int.
nat->int {{O}} 0 :- !.
nat->int T N :- unify-eq T (app [{{@S}}, X]), !,
  nat->int X N', N is N' + 1.
nat->int _ _ :- fatal-error "nat->int: not a nat".

pred int->nat i:int, o:term.
int->nat 0 {{O}} :- !.
int->nat N (S X) :- N > 0, !, N' is N - 1, int->nat N' X.
int->nat _ _ :- fatal-error "int->nat: negative number".

pred retrieve-param i:instance, o:prop.
retrieve-param (instance T _) (param Nary X X1 XR :- !) :- !,
  coq-env-typeof-gr {term->gr T} (app [NaryNat, _, _, _, _, X, X1, XR]),
  nat->int NaryNat Nary.

pred store-param-all-indc i:int, i:(list term), o:(list term).
% @log(store-param-all-indc _ _).
store-param-all-indc _Nary [] [] :- !.
store-param-all-indc Nary [K|Ks] [KR|KRs] :- !,
  KR = indc GR,
  store-param Nary GR K K KR, store-param-all-indc Nary Ks KRs.

pred store-param i:int, i:string, i:term, i:term, i:term.
% @log(store-param _ _ _ _).
store-param Nary N X X1 XR :- !,
  int->nat Nary NaryNat,
  Nparam is "param_" ^ {coq-name->string {coq-gr->name N}},
  Args = [NaryNat, hole, hole, hole, X, X1, XR],
  coq-elaborate (app [{{@store_param}}|Args]) T1 T2,
  coq-env-add-const Nparam T1 T2 (const GR),
  coq-TC-declare-instance GR 0 tt.

%%%%%%%%%%%%%%%%%%%%%%%
% toplevel predicates %
%%%%%%%%%%%%%%%%%%%%%%%

pred with-TC-param i:prop.
with-TC-param P :- with-TC {{@param_db}} retrieve-param P.

pred param-term i:int, i:term, o:term, o:term, o:(list term), o:(list term), o:term, o:term.
% @log(param-term _ _ _ _ _ _).
param-term Nary X X' Ty' X1' Ty1' XR' TyR :- !,
  with-TC-param (param Nary X X1 XR),
  coq-elaborate X X' Ty,
  map X1 (x\ res\ sigma P1 P2\ coq-elaborate x P1 P2, res = pr P1 P2) XTy1,
  map XTy1 fst X1', map XTy1 snd Ty1,
  coq-elaborate XR XR' TyR.

pred param-const i:int, i:term, o:term, o:term, o:(list term), o:(list term), o:term, o:term.
% @log(param-const _ _ _ _ _ _).
param-const Nary (const GR as Const) X Ty X1 Ty1 XR TyR :- !,
  coq-env-const GR V _,
  param-term Nary V X Ty X1 Ty1 XR TyR.
param-const _Nary NotAConst _X _Ty _X1 _Ty1 _XR _TyR :- !,
  $coq-say "Not a const:" NotAConst, fail.

pred env-add-param i:int, i:term, i:string.
env-add-param Nary (const GR as Term) NameR :- !,
 do! [
  param-const Nary Term X Ty X1 Ty1 XR TyR,
  coq-env-add-const NameR XR TyR TermR,
  store-param Nary NameR Term Term TermR
].

pred env-add-param i:int, i:term, i:string.
env-add-param Nary (indt GR as Ind) NameR :- !,
 do! [
  coq-env-indt GR IsInd Lno Luno Ty Knames Ktypes,
  coq-env-indt->decl Ty Lno Ind Knames Ktypes Decl,
  with-TC-param
     (param-indt Nary GR IsInd Lno Luno Ty Knames Ktypes
 	   	 NameR IsIndR LnoR LunoR TyR KnamesR KtypesR),
  whd {mk-app TyR [Ind, Ind]} [] TyRIIwhd _,
  $coq-say "TyRIIwhd=" TyRIIwhd,
  coq-env-indt->decl {subst-lam [Ind, Ind] TyR} LnoR
      (indt NameR) KnamesR KtypesR DeclR,
  spy(coq-env-add-indt DeclR (indt GRR)),
  store-param Nary NameR Ind Ind (indt GRR),
  coq-env-indt GRR _ _ _ _ RealNamesR _,
  store-param-all-indc Nary Knames RealNamesR
 ].

%%%%%%%%%%%%%%%%%%%%%
% Tactic entrypoint %
%%%%%%%%%%%%%%%%%%%%%

% We disable coq-refiner
:before "refiner-declare-evar"
  declare-evar _ Ev Ty :- !, evar Ev Ty.

:before "refiner-declare-goal-evar"
  declare-goal-evar _ Ev Ty Ev :- !, evar Ev Ty.

pred ctx->TC i:(list prop), o:(list (pair term term)).
ctx->TC [] [] :- !.
ctx->TC [decl X _ Ty |Xs] [pr X Ty|Is] :- !, ctx->TC Xs Is.
ctx->TC [def X _ _ _ Ty |Xs] [pr X Ty|Is] :- !, ctx->TC Xs Is.

solve [goal Ctx Ev (app[{{@param}}, NaryNat, T, TR, X, XR]) _] :- !,
  coq-evd-print,
  nat->int NaryNat Nary,
  $coq-say "goal->TC" {ctx->TC Ctx},
  $coq-say "searching" Nary "param for" X,
  with-TC-param (param Nary T _ TR),
  with-TC-param (param Nary X _ XR),
  Ev = app [{{@Param}}, NaryNat, T, TR, X, XR],
  coq-typecheck Ev Ty,
  $coq-say "Ty=" Ty.
