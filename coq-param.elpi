/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% improve coq-env-indt->decl and subst-prod by calling whd %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:before "coq-env-indt->decl:fail"
coq-env-indt->decl T Lno Iname Kns Ktys Idecl :-
  unwind {whd T []} R,
  assert (R = prod _ _ _) "coq-env-indt->decl: Lno > #products(arity)",
  coq-env-indt->decl R Lno Iname Kns Ktys Idecl.

:before "subst-prod:fail"
subst-prod ([X|XS] as Args) T P :-
  unwind {whd T []} R,
  assert (R = prod _ _ _) "subst-prod: not a prod even after whd",
  subst-prod Args R P.

%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional primitives %
%%%%%%%%%%%%%%%%%%%%%%%%%

pred abstract i:term, i:(list term), i:term, o:term.
% @log(abstract T Args Prod Lam).
abstract T [] _ T' :- !, copy T T'.
abstract T [X|XS] (prod N Ty Tys) (lam N Ty R) :- !,
  pi x\ copy X x => abstract T XS (Tys x) (R x).

pred nat->int i:term, o:int.
@log(nat->int N I).
nat->int Z 0 :- unify-eq Z {{O}}, !.
nat->int T N :- unify-eq T (app [{{@S}}, X]), !,
  nat->int X N', N is N' + 1.
nat->int _ _ :- fatal-error "nat->int: not a nat".

pred int->nat i:int, o:term.
int->nat 0 {{O}} :- !.
int->nat N SX :- N > 0, !, N' is N - 1,
  int->nat N' X, mk-app {{@S}} [X] SX.
int->nat _ _ :- fatal-error "int->nat: negative number".

pred list-elpi->coq i:(list term), o:term.
list-elpi->coq [] (app[{{@nil}},{{@gen}}]) :- !.
list-elpi->coq [X|Xs] Gens :- !,
  coq-elaborate X X' Ty',
  Gens = app [{{@cons}}, {{@gen}}, app[{{@Gen}}, Ty', X'],
              {list-elpi->coq Xs}].

pred list-coq->elpi i:term, o:(list term), o:(list term).
list-coq->elpi Nil [] [] :- unify-eq Nil (app[{{@nil}},_]), !.
list-coq->elpi Gens [X|Xs] [Ty|Tys] :- !,
  unify-eq Gens (app [{{@cons}}, _, app[{{@Gen}}, Ty, X], XsTys]),
  list-coq->elpi XsTys Xs Tys.

pred nseq i:int, i:A, o:(list A).
nseq 0 X [] :- !.
nseq N X [X|Xs] :- N > 0, !, N' is N - 1, nseq N' X Xs.

pred iter-i i:int, i:(int -> A), i:B, i:(A -> B -> B), o:B.
iter-i 0 _F Acc _K Acc :- !.
iter-i N F Acc K Res :- N > 0, !, N' is N - 1,
  iter-i N' F (K (F N') Acc) K Res.

pred fun-of-list i:A, i:(list A), o:(int -> A -> prop).
fun-of-list Default [] (_\ r\ r = Default) :- !.
fun-of-list _Default [X|Xs] (n\ r\ n = 0, ) :- !,
  fun-of-list X Xs F.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parametricty translation %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred param-args i:int, i:(list term), o:(int -> list term), o:(list term).
param-args Nary [] (_\ []) [] :- !.
%@log(param-args _ _ _).
param-args Nary [X|Xs] (n\ [X1 n|Xs1 n]) ArgsR :- !,
  spy(param Nary X X1 XR), !,
  spy(param-args Nary Xs Xs1 XsR), !,
  iter-i Nary X1 [] :: X1list,
  flatten [[X|X1list],[XR|XsR]] ArgsR.

pred map-param i:int, i:(list term), o:(int -> (list term)), o:(list term).
map-param _Nary [] (_\ []) [] :- !.
map-param Nary [X|Xs] (n\ [X1 n|Xs1 n]) [XR|XsR]:- !,
  param Nary X X1 XR, !, map-param Nary Xs Xs1 XsR, !.

% pred fold-op i:(A -> (C -> Ret) -> Ret),
%   i:(list A), o:((list C -> Ret) -> Ret -> prop).
% %@log(fold-op2 _ _ _ _).
% fold-op Op [] (subst\ ret\ subst [] ret) :- !.
% fold-op Op [A|As] Ops :- !, fold-op Op As Ops', !,
%   Ops = subst\ ret\
%         ((pi x\ Ops' (args\ ret\ subst [x|args] ret) (B x)),
%         ret = Op A B).

% pred fold-op2 i:(A -> B -> (C -> Ret) -> Ret),
%   i:(list A), i:(list B), o:((list C -> Ret -> prop) -> Ret -> prop).
% %@log(fold-op2 _ _ _ _).
% fold-op2 Op [] [] (subst\ ret\ subst [] ret) :- !.
% fold-op2 Op [A|As] [B|Bs] Ops :- !,
%   spy(fold-op2 Op As Bs Ops'), !,
%   Ops = subst\ ret\ sigma C\
%         ((pi x\ Ops' (args\ ret\ subst [x|args] ret) (C x)),
%          ret = Op A B C).
% fold-op2 _Op [] [_|_] _ :- fatal-error "fold-op2: list size mismatch".
% fold-op2 _Op [_|_] [] _ :- fatal-error "fold-op2: list size mismatch".

% pred fold-op3 i:(A -> B -> C -> (D -> Ret) -> Ret),
%   i:(list A), i:(list B), i:(list C), o:((list D -> Ret -> prop) -> Ret -> prop).
% %@log(fold-op3 _ _ _ _).
% fold-op3 Op [] [] [] (subst\ ret\ subst [] ret) :- !.
% fold-op3 Op [A|As] [B|Bs] [C|Cs] Ops :- !,
%   fold-op3 Op As Bs Cs Ops', !,
%   Ops = subst\ ret\
%         ((pi x\ Ops' (args\ ret\ subst [x|args] ret) (D x)),
%         ret = Op A B C D).
% fold-op3 _Op [] [] [_|_] _ :- fatal-error "fold-op3: list size mismatch".
% fold-op3 _Op [] [_|_] [] _ :- fatal-error "fold-op3: list size mismatch".
% fold-op3 _Op [_|_] [] [] _ :- fatal-error "fold-op3: list size mismatch".

pred hoas-flatten i:int, i:((int -> term) -> (int -> term)), o:(int -> term -> term).
hoas-flatten N F (n\ t\ F (_\t) n) :- !.

pred param-sort i:int, i:term, i:(term -> term), o:term.
param-sort 0 P F (F P) :- !.
param-sort N P F (lam "s" P B) :- N > 0, !, N' is N - 1,
  pi x\ param-sort N' P (y\ F (prod "s" x _\ y)) (B x).

pred param i:int, i:term, o:(int -> term), o:term.
@log(param Nary P (_\ P) _).
param Nary (sort _ as P) Ps PR :- !,
  Nary1 is Nary + 1,
  param-sort Nary1 P (x\x) PR.
 
  % pi xs\ fold-op2 prod ["s"|Names] xs (Prods xs)

param Nary (lam N T B) Lam1 LamR :- !,
  % nseq Nary N Names, 
  param Nary T T1 TR, !,
  (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
  hoas-flatten Nary B1 B1s, !,
  iter-i Nary (n\ lam N (T1 n) (B1s n)) [] :: Lam1, !,
  (pi x\ iter-i Nary (n\ lam N (T1 n))
         (x1\ lam N {mk-app TR [x|x1]} xR\ BR x x1 xR)
	 (l\ t\ (x1\ l x\ t [x|x1])) (LamR' x)),
  LamR = Lam N T x\ (LamR' x []).

% param Nary (prod N T P as Prod) Prod1 ProdR :- !,
%   nseq Nary N Names, spy(param Nary T T1 TR), !,
%   spy((pi x xR\ pi-list-var Nary (x1\ param Nary x x1 xR) (Cond x xR))),
%   spy((pi x x1 xR\ Cond x xR x1 => param Nary (P x) (P1 x1) (PR x x1 xR))),
%   spy(hoas-flatten Nary P1 P1s), !,
%   spy(map3 Names T1 P1s (n\ t\ b\ res\ spy(res = prod n t b)) Prod1), !,
%   spy(fold-op2 prod Names T1 Prod1s),
%   $coq-say "Prod1s=" Prod1s,
%   fold-op2 lam {nseq Nary "f"} Prod1 Lam1s,
%   $coq-say "Lam1xs=" Lam1s,
%   % (mk-prods f1 r P :- !, 
%   % ) =>,
%   (pi f\
%     Lam1s (f1\r\ sigma ProdR'\
%       (pi x\ spy(Prod1s (x1\ r'\ sigma ProdArgs TRxx1 PRapp R'\
%          spy(map2 [f|f1] [x|x1] (h\v\ret\ mk-app h [v] ret) ProdArgs),
%        	 $coq-say "ProdArgs=" ProdArgs "with f=" f "f1=" f1 "x=" x "x1=" x1
% 	          "r=" r "r'=" r',
%          spy(mk-app TR [x|x1] TRxx1),
% 	 $coq-say "TR=" TRxx1,
%          (pi xR\ mk-app (PR x x1 xR) ProdArgs (PRapp xR)),
% 	 $coq-say "PRapp=" PRapp,  
%          R' = prod N TRxx1 PRapp,
% 	 spy(r' = R'))
%        (ProdR' x))),
%        $coq-say "ProdR'=" ProdR',
%        r = prod N T ProdR')
%      (LamR' f)),
%        % $coq-say "Lam1s r=" r (LamR' f)),
%        % $coq-say "Hello",
%   ProdR = lam "f" Prod LamR'.

% param Nary (app [A|Bs]) A1Bs1 ARBsR :- !,
%    param Nary A A1 AR, !, spy(param-args Nary Bs Bs1 BsR), !,
%    spy(map2 A1 Bs1 mk-app A1Bs1), !, mk-app AR BsR ARBsR.

% param Nary (let N T V B) Let1 LetR :- !,
%   nseq Nary N Names, param Nary T T1 TR, !, param Nary V V1 VR, !,
%   (pi x x1 xR\ param Nary x x1 xR => param Nary (B x) (B1 x1) (BR x x1 xR)), !,
%   hoas-flatten Nary B1 B1s, !,
%   map4 Names T1 V1 B1s (n\ t\ v\ b\ res\ res = let n t v b) Let1, !,
%   fold-op3 let Names T1 V1 Let1s,
%   (pi x\ Let1s (x1\ r\ r = let N TR VR xR\ BR x x1 xR) (LetR' x)),
%   LetR = let N T V LetR'.
  
% param Nary (match T P Bs) M1 MR :- !,
%   param Nary T T1 TR, !, param-match Nary P P1 PRM, !,
%   param Nary T T1 TR => map-param Nary Bs Bs1 BsR, !,
%   hoas-flatten Nary B1 B1s, !,
%   map3 T1 P1 Bs1 (x\y\z\res\ res = match x y z) M1,
%   map2 [P|P1] [Bs|Bs1] (p\bs\res\ res = x\ match x p bs) PRMArgs,
%   MR = match TR (PRM PRMArgs) BsR.

% param (fix N Rno T F as Fix) Fix1 FixR :- !,
%   RnoR is 3 * Rno + 2, RnoR1 is RnoR + 1,
%   param T T1 TR, !,
%   (pi x x1 xR\ param x x1 xR => param (F x) (F1 x1) (FR x x1 xR)), !,
%   Fix1 = fix N Rno T1 F1, !,
%   (TRsubst = f\ f1\ {subst-lam [f, f1] TR}), !,
%   coq-typecheck (lam "f" T f\ lam "g" T1 f1\
%                  lam "xR" (TRsubst f f1) xR\ FR f f1 xR) Ty, !,
%   % TODO: add typing constraints for U and U1 before unification
%   unify-eq Ty (prod Nf Tf f\ prod Nf1 Tf1 f1\ prod _ _ xR\
%                 TRsubst (U f) (U1 f1)), !,
%   coq-typecheck (lam "x" Tf U) Tu, !,
%   coq-typecheck (lam "x" Tf1 U1) Tu1, !,
%   (pi f f1 xR\ FixBody f f1 xR =
%      let "U" Tu (lam Nf Tf U) u\ let "U1" Tu1 (lam Nf1 Tf1 U1) u1\
%      let "FR" (TRsubst {mk-app u [f]} {mk-app u1 [f1]}) (FR f f1 xR) fr\
%       {mk-trivial-match RnoR (TRsubst f f1) [] fr}),
%   (pi f f1 xR\ mk-eta (RnoR + 1) (TRsubst f f1) (FixBody f f1 xR)
%               (EtaFixBody f f1 xR)), !,
%   FixR = (let N T Fix f\ let N T1 Fix1 f1\
%           fix N RnoR (TRsubst f f1) xR\ EtaFixBody f f1 xR).

:name "param:end"
param Nary X _ _ :- !, $coq-say "No" Nary "param for " X, fail.

% pred mk-trivial-match i:int, i:term, i:list term, i:term, o:term.
% %@log(mk-trivial-match _ _ _ _ _).
% mk-trivial-match Rno Prod Args F (lam N T B) :- Rno > 0, !,
%   unify-eq Prod (prod N T P), Rno' is Rno - 1,
%   (pi x \ mk-trivial-match Rno' (P x) [x|Args] F (B x)).
% mk-trivial-match 0 Prod Args F Transport :- !,
%   unify-eq Prod (prod N T P), !,
%   (pi x\ rev [x|Args] (RArgs x)), !,
%   safe-dest-app T (indt Name as Ind) IndArgs, !,
%   coq-env-indt Name _ Lno _Luno IndArity KNames KTypes, !,
%   split-at Lno IndArgs LIndArgs RIndArgs, !,
%   subst-prod LIndArgs IndArity RIndArity, !,
%   abstract (lam N T P) RIndArgs RIndArity MatchType, !,
%   (AbsF = x\ {abstract {mk-app F (RArgs x)} RIndArgs RIndArity}), !,
%   map KNames (k\ subst-lam LIndArgs k) RKs, !,
%   map KTypes (subst-prod LIndArgs) RKTypes, !,
%   map2 RKs RKTypes (mk-branch-lams Lno T AbsF) Branches, !,
%   Transport = (lam N T x \ match x MatchType Branches).

% pred mk-branch-lams i:int, i:term, i:(term -> term), i:term, i:term, o:term.
% % @log(mk-branch-lams _ _ _ _ _).
% mk-branch-lams Lno T F K (prod N Ty P) (lam N Ty B1) :- !,
%   (pi x\ mk-branch-lams Lno T F {subst-lam [x] K} (P x) (B1 x)).
% mk-branch-lams Lno T F K P Let :- !,
%   safe-dest-app P _ ParamIndexes, !,
%   split-at Lno ParamIndexes _Param Indexes, !,
%   (Let = let "K" P K x\ {subst-lam Indexes (F x)}).

% % helpers for match return type

% pred pi-list-var i:int, i:(list term -> prop), o:(list term -> prop).
% pi-list-var 0 F (_\ F []) :- !.
% pi-list-var N F Prop' :- N > 0, !, N' is N -  1,
%   (pi x\  pi-list-var N' (xs\ F [x|xs]) (Prop x)),
%   Prop' = xs\ sigma Hd Tl\ xs = [Hd|Tl], Prop Hd Tl.

% pred param-match i:int, i:term, o:(list term), o:((list (term -> term)) -> term).
% param-match Nary (lam N T B) P1 PRM :- pi x\ not (B x = lam _ _ _), !,
%   nseq Nary N Names, param Nary T T1 TR, !,
%   (pi x xR\ pi-list-var Nary (x1\ param Nary x x1 xR) (Cond x xR)),
%   (pi x x1 xR\ Cond x xR x1 => param Nary (B x) (B1 x1) (BR x x1 xR)),
%   hoas-flatten Nary B1 B1s, !,
%   map3 Names T1 B1s (n\ t\ b\ res\ res = lam n t b) P1, !,
%   fold-op2 lam Names T1 Lam1s, 
%   (pi zs x\ Lam1s (x1\ r\ sigma BRArgs\
%      map2 zs [x|x1] (z\x\res\ res = z x) BRArgs,
%      r = lam N {mk-app TR [x|x1]} xR\
%      {mk-app (BR x x1 xR) BRArgs}) (LamR' zs x)),
%   (pi zs\ PRM zs = lam N T (LamR' zs)).

% param-match Nary (lam N T B) P1 PRM :-
%   nseq Nary N Names, param Nary T T1 TR, !,
%   (pi x x1 xR\ param Nary x x1 xR => param-match Nary (B x) (B1 x1) (BR x x1 xR)), !,
%   hoas-flatten Nary B1 B1s, !,
%   map3 Names T1 B1s (n\ t\ b\ res\ res = lam n t b) P1, !,
%   fold-op2 lam Names T1 Lam1s, 
%   (pi zs x\ Lam1s (x1\r\ r = lam N {mk-app TR [x|x1]} xR\ BR x x1 xR zs) (LamR' zs x)),
%   (pi zs\ PRM zs = lam N T (LamR' zs)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% translation of inductive types %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred param-indt i:int, i:@gref, i:bool, i:int, i:int, i:term, i:list term, i:list term,
     i:string, o:bool, o:int, o:int, o:term, o:list term, o:list term.
%@log(param-indt _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
param-indt Nary GR IsInd Lno Luno Ty Knames Ktypes
 	   NameR IsInd LnoR LunoR TyR KnamesR KtypesR :- !,
  LnoR is Nary * Lno,
  nseq Nary (indt GR) Ind1,
  param Nary (indt GR) Ind1 (indt NameR) => (
    spy(param Nary Ty _ TyR),
    map Knames (rename-indc NameR) KnamesR,
    spy(map2 Knames Ktypes (param-indc Nary) KtypesR)).

pred rename-indc i:string, i:term, o:term.
% @log(rename-indc N I _).
rename-indc NameR (indc GR) (indc NameR') :- !,
  coq-name->string {coq-gr->name GR} Name,
  NameR' is NameR ^ "_" ^ Name.

pred param-indc i:int, i:term, i:term, o:term.
% @log(param-indc N K T _).
param-indc Nary K T TRK :- !,
  spy(param Nary T _ TR),
  nseq Nary K Ks,
  mk-app TR [K|Ks] TRK.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Class storage functions: %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred retrieve-param i:instance, o:prop.
retrieve-param (instance T _) (param Nary X X1 XR :- !) :- !,
  coq-env-typeof-gr {term->gr T} (app [_, NaryNat, _, _, _, X, X1enc, XR]),
  list-coq->elpi X1enc X1list _,
  
  nat->int NaryNat Nary.

pred store-param-all-indc i:int, i:(int -> term), o:(list term).
% @log(store-param-all-indc _ _).
store-param-all-indc _Nary [] [] :- !.
store-param-all-indc Nary [K|Ks] [KR|KRs] :- !,
  KR = indc GR, nseq Nary K K1,
  store-param Nary GR K K1 KR, store-param-all-indc Nary Ks KRs.

pred store-param i:int, i:string, i:term, i:(list term), i:term.
% @log(store-param _ _ _ _).
store-param Nary N X X1 XR :- !,
  int->nat Nary NaryNat,
  Nparam is "param_" ^ {coq-name->string {coq-gr->name N}},
  iter-i Nary X1 :: [] X1list
  list-elpi->coq X1list X1enc,
  Args = [NaryNat, hole, hole, hole, X, X1enc, XR],
  coq-elaborate (app [{{@store_param}}|Args]) T1 T2,
  coq-env-add-const Nparam T1 T2 (const GR),
  coq-TC-declare-instance GR 0 tt.

%%%%%%%%%%%%%%%%%%%%%%%
% toplevel predicates %
%%%%%%%%%%%%%%%%%%%%%%%

pred with-TC-param i:prop.
with-TC-param P :- with-TC {{@param_db}} retrieve-param P.

pred param-term i:int, i:term, o:term, o:term, o:(list term), o:(list term), o:term, o:term.
% @log(param-term _ _ _ _ _ _).
param-term Nary X X' Ty' X1' Ty1' XR' TyR :- !,
  with-TC-param (param Nary X X1 XR),
  coq-elaborate X X' Ty,
  map X1 (x\ res\ sigma P1 P2\ coq-elaborate x P1 P2, res = pr P1 P2) XTy1,
  map XTy1 fst X1', map XTy1 snd Ty1,
  coq-elaborate XR XR' TyR.

pred param-const i:int, i:term, o:term, o:term, o:(list term), o:(list term), o:term, o:term.
% @log(param-const _ _ _ _ _ _).
param-const Nary (const GR as Const) X Ty X1 Ty1 XR TyR :- !,
  coq-env-const GR V _,
  param-term Nary V X Ty X1 Ty1 XR TyR.
param-const _Nary NotAConst _X _Ty _X1 _Ty1 _XR _TyR :- !,
  $coq-say "Not a const:" NotAConst, fail.

pred env-add-param i:int, i:term, i:string.
env-add-param Nary (const GR as Term) NameR :- !,
 do! [
  param-const Nary Term X Ty X1 Ty1 XR TyR,
  coq-env-add-const NameR XR TyR TermR,
  nseq Nary Term Term1,
  store-param Nary NameR Term Term1 TermR
].

pred whd-red i:term, o:term.
whd-red T T' :- !, mk-app {whd T []} T'.

pred env-add-param i:int, i:term, i:string.
env-add-param Nary (indt GR as Ind) NameR :- !,
 do! [
  coq-env-indt GR IsInd Lno Luno Ty Knames Ktypes,
  spy(coq-env-indt->decl Ty Lno Ind Knames Ktypes Decl),
  with-TC-param
     (param-indt Nary GR IsInd Lno Luno Ty Knames Ktypes
 	   	 NameR IsIndR LnoR LunoR TyR KnamesR KtypesR),
  nseq Nary Ind Ind1,
  whd-red {mk-app TyR [Ind|Ind1]} TyRIIwhd,
  map KtypesR (x\res\ sigma X C\ whd x [] X C, mk-app X C res) KtypesRwhd,
  spy(coq-env-indt->decl TyRIIwhd LnoR
      (indt NameR) KnamesR KtypesRwhd DeclR),
  spy(coq-env-add-indt DeclR (indt GRR)),
  spy(store-param Nary NameR Ind Ind1 (indt GRR)),
  coq-env-indt GRR _ _ _ _ RealNamesR _,
  store-param-all-indc Nary Knames RealNamesR
 ].

%%%%%%%%%%%%%%%%%%%%%
% Tactic entrypoint %
%%%%%%%%%%%%%%%%%%%%%

% We disable coq-refiner
:before "refiner-declare-evar"
  declare-evar _ Ev Ty :- !, evar Ev Ty.

:before "refiner-declare-goal-evar"
  declare-goal-evar _ Ev Ty Ev :- !, evar Ev Ty.

pred ctx->TC i:(list prop), o:(list (pair term term)).
ctx->TC [] [] :- !.
ctx->TC [decl X _ Ty |Xs] [pr X Ty|Is] :- !, ctx->TC Xs Is.
ctx->TC [def X _ _ _ Ty |Xs] [pr X Ty|Is] :- !, ctx->TC Xs Is.

solve [goal Ctx Ev (app[{{@param}}, NaryNat, T, TR, X, XR]) _] :- !,
  coq-evd-print,
  nat->int NaryNat Nary,
  $coq-say "goal->TC" {ctx->TC Ctx},
  $coq-say "searching" Nary "param for" X,
  with-TC-param (param Nary T _ TR),
  with-TC-param (param Nary X _ XR),
  Ev = app [{{@Param}}, NaryNat, T, TR, X, XR],
  coq-typecheck Ev Ty,
  $coq-say "Ty=" Ty.
